

相关思想还有：拒绝采样



## 高楼扔鸡蛋

有100层楼以及两个鸡蛋，请问最坏情况下，可以用几次就能测出鸡蛋在哪个楼层扔下刚好会碎？

二分：先在第50层扔，如果没碎就去75层，以此类推。如果第一个鸡蛋在50层碎了则另一个鸡蛋保险起见只能从第一层开始扔。所以最坏情况(就是50层才刚好碎)1 + 49 = 50次

多分：先在第10层扔，然后20层，以此类推。如果第一个鸡蛋在20层碎了则另一个鸡蛋保险起见只能从第十一层开始扔，所以最坏情况（就是100层刚好碎）10 + 9 = 19次

逆向：假设正确答案是X次。则**第一次扔的楼层一定不会超过X层**（如果第一次超过x层并且碎了，最坏情况下就大于x次，x就不可能是答案），同样**第二次不能超过X+(X-1）层**（减一是因为第一次扔消耗了一次机会），最后一次一定是1层，因为只有这样才能唯一确定。因此:

X + (X-1) + (X -2).....+1 = 100

X向上取整为14



## 生成随机数

例如rand7 生成rand10，rand7代表可以均匀生成1-7

(rand_X() - 1) × Y + rand_Y() ==> 可以等概率的生成[1, X * Y]范围的随机数

rand7-1   则均匀生成 0，1，2，3，4，5，6

x7           则均匀生成 0，7，14，21，28，35，42

rand7   则均匀生成 1，2，3，4，5，6，7

最后两行的数字**上下必选一个相加**都可以生成一个[1,49]里唯一的数，通过拒绝采样和映射就能简单获取rand10

rand3 rand5 生成rand8

0，1，2，3，4

0，3，6，9，12

1，2，3

同理

## 背包问题

### 01背包

有N件物品和最大容量为W的背包，每件物品的价值(v[i])和重量(w[i])都不同，如何选择才能让总价最大？

`dp[i][j]`含义为：当背包容量为J时，在编号[0...i]的物品中选取时所能获得的最大价值

转移方程：

```
dp[i][j] = max(dp[i-1][j])，dp[i-1][j-w[i]] + v[i])
```

理解：当背包容量固定为J时，出现了一个新的物品i，（这里隐藏含义在于，在没有出现物品i时，对于**相同容量J**，已经有了最有价值的解`dp[i-1][j]`）有两种可能：

1. 这个新的物品价值太低了且不能直接放进去，因此我不想用它替换现有的物品，因此仍然等于`dp[i-1][j]`,及没出现物品i时候的最大价值
2. 这个物品价值太了高了，我要替换原有的物品或者可以直接放进去，使这个物品可以正好放进去(隐藏含义，拿出来的也尽可能少，甚至不拿出来，尽可能使背包容量用满)。因此为`dp[i-1][j-w[i]] + v[i]`**即减少当前物品的容量情况下的最优解**加上当前物品的价值。(此可能还需要满足条件`j>=w[i]`，也就是至少背包容量要比i的容量大才能换)

最终得到了上述的转移方程。

假设背包最大容量为4数据为：

|   -   | 重量 | 价值 |
| :---: | :--: | :--: |
| 物品0 |  1   |  15  |
| 物品1 |  3   |  20  |
| 物品2 |  4   |  30  |



则按行填充dp数组为：

|   -   | 容量为0 | 容量为1 | 容量为2 | 容量为3 | 容量为4 |
| :---: | :-----: | :-----: | :-----: | :-----: | :-----: |
| 物品0 |    0    | **15**  |   15    |   15    |   15    |
| 物品1 |    0    |   15    |   15    |   20    | **35**  |
| 物品2 |    0    |   15    |   15    |   20    |   30    |

理解：第一行非常容易，因为只有一个物品0因此，如果背包容量放不进就是0，放的进就是物品0的价值

第二行对于前三个来说，物品1的容量比总容量还大因此和物品0相同。对于第四个考虑上述转移方程`dp[i-1][j-w[i]] + v[i]，`  显示`dp[0][0] + 20 == 20`大于`dp[0][3] == 15`也就是说使用物品1替换物品0。对于第五个 `dp[0][1] + 20 == 35` 大于 `dp[0][4] == 15`因此是35	

第三行同理



转换为代码就是 外层循环是物品，内存循环是容量。并且为了防止单个物品的重量就超过了背包容量，因此内循环应该是倒序从最大容量开始，直到和单个物品i相等，即：

```java
for(Product product : products) {
    for(int j = W; j >= product.weight(); j--) {
        //....
    }
}
```



再次观察这个转移方程：

```
dp[i][j] = max(dp[i-1][j])，dp[i-1][j-w[i]] + v[i])
```

可以发现，第i行第j列的数据只由**第i-1行第小于等于j列**的数据生成，因此可以将二维转化为一维变成滚动数组。

```java
for(Product product : products) {
    for(int j = W; j >= product.weight(); j--) {
        dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

这里内层循环使用倒叙的另一个重要原因时，当使用了滚动数组如果从左开始写，那之后的数据生成时就用不了上一行**小于等于j列**的数据了，因为这个数据在本行之前的数据迭代中被**覆盖**了，变成了这一行的值。

理解核心：

1. 识别出这个是01背包问题
2. 脑内建立dp表，行维度是取[0..i]个物品，列维度是目标值[0....target]
3. 开始初始化第一行
4. 利用滚动数组思想，写一维转移方程，**其中关键在于如果要使用当前物品I，那就要获取扣减当前物品重量的现有最优解dp[j - w[i]]**
5. 按照脑内DP图，确定外层循环时物品，内层循环是target。为了避免滚动数组污染内层从最右边开始，记得考虑**dp[j - w[i]]数组越界问题**









