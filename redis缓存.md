# Redis

## 数据结构

1、String

底层实现是**SDS**(simple dynamic string)。

```c
struct SDS {
	len;  //字符串长度
	alloc //分配的空间长度
	flags //sds类型  sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64 节省空间
	buf[] //字节数组
}
```



为什么不用C语言自带的char?

* 不能有/0，因为C语言字符数组会使用此符号判断结尾
* 获取长度的时间复杂度为哦o(n)
* 不能保存图片音视频等二进制文件
* c语言是手动分配缓冲区大小的，可能oom

2、list

底层实现是**双向链表**或者是**压缩列表**

还额外提供了，链表头和链表尾和长度三种属性。

如果元素很少且是小整数值或是短字符串会使用压缩列表，类似于数组

| zlbytes（总共占有字节数） | ztail(列表尾偏移量) | zllen（总节点数） | entry1 | entry2 | ....... | zlend（结束标记 Oxff 也就是255） |
| ------------------------- | :-----------------: | :---------------: | :----: | :----: | :-----: | :------------------------------: |

每个entry包括

| prevlen（前一个节点长度） | encoding(当前节点数据类型和长度) | data(实际数据) |
| :-----------------------: | :------------------------------: | :------------: |

这种结构查询时间复杂度高除了头尾元素都是O(n)。并且可能会触发连锁更新，因为prevlen占用的空间会根据前一个节点大小的变化而变化。一个扩容后面可能都会导致扩容

3、hash

底层实现是**哈希表**或者是**压缩列表**

哈希表结构就是**数组加链表**，

扩容方式（渐进式hash）：

1. 分配一个两倍大的空间。
2. 每次请求的时候顺序迁移，此期间所有操作都会在两张表同时进行（除了插入只会插入新表）
3. 迁移万后释放

扩容时机：

* 负载因子大于等于1，没有执行RDB或AOF操作时进行rehash
* 负载因子大于等于5 ,强制进行rehash

4、set

**hash表**或**整数数组**

5、sorted set

底层实现时**跳表**或**压缩列表**（可以存相同的数据）

为什么使用跳表

* 要支持随机插入和删除后的排序，所以不宜用数组，树的rebalance成本较高，实现复杂

在链表结构基础上为每个节点随机出一个层数，形成一个多层链表结构，插入新的节点只需要修改前后涉及到的层数指针。查询时也只要从最上层开始查找一层层往往下

6、hyperloglog

用来不精确统计基数大小

7、geo

用来存储经纬度计算距离等

## 为什么那么快

* 内存操作
* 网络IO多线程
* 处理单线程避免处理同步问题与线程切换损耗
* 优化的数据结构

## 多线程

## 缓存一致性问题

### 延迟双删

先删缓存，再更新数据库，延迟一会儿，再删缓存。

Q:为什么要删两次？

A: 第一次：尽量避免脏数据。如果没有这步，一方面会使脏数据存在更长时间，另一方面如果第二次删缓存失败，则会一直有脏数据，所以先尽量保证缓存删除成功。第二次：防止第一次删除之后，到更新完数据库之前有请求进来，又往redis里写脏数据。

Q:为什么要延迟一会儿？

A:防止出现线程A查询数据库，线程B更新数据库，线程B删除缓存，线程A更新缓存为脏数据的情况。

Q:可以使用更新操作嘛？

A:更新操作可能出现两个线程并发更新导致旧数据复写新数据的情况，但也可以使用乐观锁时间戳解决。原子更新数据库`version = version+1`+select返回数据和version。redis cas判断缓存中的version是否相差一，version可以拼在key后面

### binlog监听

监听binlong变更信息后投递mafka消息进行消费，如果失败进行重试。还是失败则告警进行人工处理。

## 过期策略



## 缓存雪崩、穿透、击穿

1、缓存雪崩

> 指同一时间缓存大面积失效，slave如果本地时钟不对也会出现！

解决方法：

* 过期时间随机或永不过期
* 增加多级缓存

2、穿透

> 指数据库和缓存都没有值

解决方法：

* 接口层参数校验
* 短时间内对这个key缓存一个空值
* 布隆过滤器。对一个key使用多个散列函数

> 布隆过滤器：维护一个超大的**bit数组**。对于每一个key使用k个hash函数映射成多个bit位，并赋值为1。查询时如果有一个不为1则代表一定不存在，都是1大概率存在。
>
> 通过提升位数组大小和哈希函数个数可以降低错误率

3、击穿

> 缓存中没有值，同一时间大量访问数据库

解决方法：

* 互斥锁同一时间只能有一个线程访问数据库	
* 热点数据永不过期

## 高可用

### 数据同步

1、全量同步

如果是一个全新的slave需要进行全量的同步，或者`replication id` 和`offset`有错误。

replica**主动**向master发送`sync`命令请求同步，master收到命令后执行`BGSAVE`命令，生成RDB文件，此时新的变化会写入内存缓冲区与旧的RDB文件

当写完以后向replica发送RDB文件，发送完毕以后，发送缓冲区的命令。

2、增量同步

replica会**主动**向master发送`psync`命令请求同步，其中包含 replication id 和offset，并且是非阻塞的。

master会对比`replication id` 和`offset`,如果没有错误，会发送未发送过的offset数据给replication		

### 持久化

1、RDB

fork一个子进程，写一个新的rdb文件，这时新进来的数据会写在内存缓冲里，当写完旧的文件原子性重命名然后把缓冲里的数据刷进去。

优点：某个时间点的单文件数据集快照，非常紧凑，适合备份；fork一个子进程进行持久化，不会影响父进程；从大文件回复比aof更快

缺点： 容易丢失数据；在执行fork的时候会阻塞，而aof的fork只在rewrite时候进行；

2、AOF

根据aof的策略默认每隔一秒，往aof文件追加执行的命令

优点：更加不容易数据丢失；即使写到一半出现灾难，也可以使用修复工具丢弃错误的几行；

缺点：文件大；需要定期rewrite

rewrite过程:fork一个子进程，开始在一个新的临时文件中写入aof。同时这时候新的数据变化，会同时写入内存缓冲和旧的aof文件中。当子进程写完会把缓冲中的数据再追加到aof文件中。原子性更换文件名，使之指向新的文件	

### 哨兵

作用：监控、提醒、故障转移、配置提供

1、使用gossip protocols（流言协议）来确定 master节点是SDOWN还是ODOWN

2、使用投票协议(agreement protocols、raft算法)来决定是否执行自动故 障迁移

一个哨兵可以监视多个主从系统：

```
sentinel monitor mymaster 127.0.0.1 6380 2（quorum数） 
sentinel monitor othermaster 192.168.88.60 6380 4 
```

通过对主节点发送info命令获取结构拓扑图

当有quorum个sentinel认为master已经fail时即可进行failover，注意quorum只用于发现fail。

然后当有Max(quorum, majority) （其中majority是超过sentinel机器一般的数量）个sentinel投了quorum中的一台sentinel时，这时这台sentinel会作为leader去进行failover。

从replica选出没有disconnected 然后判断slave-priorty replication offset run id 来选出

哨兵本身的自动发现机制是订阅redis的频道来了解其他信息以及对主节点的判断

## 分布式锁算法



```lua
SET resource_name my_random_value NX PX 30000
```

value可以是包含当前线程号的随机值。

```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

### RedLock

1、获取当前时间（ms)

2、依次获取5台实例上的锁，同样的key随机的value，并设置一个远小于锁过期时间的加锁超时时间（几百上千倍）

3、只有获得多数ack以及在规定时间内完成才会被认为获取到锁

4、过期时间就会变为原过期时间减去加锁用时

5、如果失败 手动unlock所有实例

如果有时钟漂移现象需要减去额外的时间 

## 一致性Hash

将整个Hash空间2^32组成一个虚拟圆环，使用redis节点的IP地址或主机名哈希以后落在圆环上。

将要存储的数据进行哈希以后，也落到圆环上然后顺时针找到第一个redis节点，即为存储节点。

这样的话如果一个节点挂了，只要迁移原本该落在这个节点的数据到下一个节点即可。

**缺点：**如果节点较少，会导致数据倾斜的问题

**解决方案：虚拟节点**。对每一个redis节点计算多个哈希，生成多个虚拟节点。在存取数据的时候多一层虚拟机点->实际节点的转换

## 哈希槽

redis将整个哈希空间分为16384个哈希槽，每个节点包含一个或多个槽（slot）。key通过`CRC16(key)%16384`获得

> Q:为什么16384？
>
> A:控制心跳包的消息头大小、1W的节点已经够用、槽位越小，节点少的情况下压缩比高容易传输

添加或删除节点时只需要移动槽即可，不会造成服务不可用状态。

如果要将一个槽从节点A迁移到节点B，这个槽在A节点会变成`MIGRATING`状态，在B节点会变成`IMPORTING`状态



## 设计缓存要关心哪些方面

* 吞吐量：设计数据结构**避免数据竞争**，处理同步问题，避免伪共享。

  主要指在读取写入缓存时需要附带额外操作（更新最后访问时间，超时时间等同步问题）

* 命中率

  由淘汰策略影响。FIFO、LRU、LFU、TinyLFU

* 扩展功能

  加载器、淘汰策略选择、失效策略、事件通知、并发级别、容量控制、引用方式、统计信息、持久化

* 分布式缓存

## 其他

### expire如何在slave上生效

master过期以后发送一个delete语句给slave

